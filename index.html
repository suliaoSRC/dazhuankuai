<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>赛博钢琴 - 痕迹记忆版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010103; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00f2ff;
            pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0,242,255,0.7);
        }
        .stat { font-size: 24px; font-weight: bold; font-variant-numeric: tabular-nums; }
        #gameOver {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: 48px; font-weight: bold; text-align: center;
            display: none; background: rgba(0,0,0,0.95); padding: 40px; border: 1px solid #ff3333;
            box-shadow: 0 0 50px rgba(255,0,0,0.3); z-index: 100; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat">SCORE: <span id="score">0</span></div>
        <div class="stat">LAUNCH: <span id="launchCount">0</span>/3</div>
    </div>
    <div id="gameOver">GAME OVER<br><span style="font-size: 20px; color: #fff;">点击重启</span></div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const launchEl = document.getElementById('launchCount');
const gameOverScreen = document.getElementById('gameOver');

// *** 新增：背景痕迹画布和上下文 ***
const traceCanvas = document.createElement('canvas');
const traceCtx = traceCanvas.getContext('2d');

let width, height, score = 0, launchCount = 0, isGameOver = false;
let balls = [], bricks = [], particles = [];
let waveTime = 0;

// 音频初始化
let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playPianoNote(x) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const freq = 261.63 + (x / width) * 784.87; // C4 - G5
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.8);
}

function playBassNote(freq) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.5);
}

// 粒子生成器
function spawnParticles(x, y, color, type = 'explode', count = 12) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = type === 'trail' ? Math.random() * 2 : Math.random() * 6 + 2;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: Math.random() * 0.02 + 0.015,
            size: Math.random() * 3 + 1,
            color,
            type 
        });
    }
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    traceCanvas.width = width;
    traceCanvas.height = height;
    // 清空痕迹画布
    traceCtx.clearRect(0, 0, width, height); 
}
window.addEventListener('resize', resize);
resize();

function spawnBricks(y = 50) {
    const cols = Math.floor(width / 90);
    const bW = (width - 40) / cols;
    for (let i = 0; i < cols; i++) {
        if (Math.random() > 0.6) {
            bricks.push({
                x: 20 + i * bW, y: y,
                w: bW - 10, h: 22,
                color: `hsl(${i * (360/cols)}, 70%, 60%)`
            });
        }
    }
}

function initGame() {
    score = 0; launchCount = 0; isGameOver = false;
    balls = []; bricks = []; particles = [];
    scoreEl.innerText = "0"; launchEl.innerText = "0";
    gameOverScreen.style.display = 'none';
    traceCtx.clearRect(0, 0, width, height); // 重启时清空痕迹
    for(let i = 0; i < 4; i++) spawnBricks(60 + i * 40);
}

function getStringY(x) {
    const xPos = x / width * 5;
    const wave1 = Math.sin(xPos + waveTime * 0.4) * 25;
    const wave2 = Math.cos(xPos * 0.7 - waveTime * 0.3) * 15;
    return height * 0.85 + wave1 + wave2;
}

canvas.addEventListener('mousedown', (e) => {
    initAudio();
    if (isGameOver) return;
    if (e.clientY > height / 2) {
        balls.push({ x: e.clientX, y: e.clientY, vx: (Math.random()-0.5)*2, vy: 8, radius: 8, hue: Math.random()*360 });
        launchCount++;
        playBassNote(400);
        spawnParticles(e.clientX, e.clientY, '#00f2ff', 'explode', 15); // 发射粒子也使用explode
        if (launchCount >= 3) {
            launchCount = 0;
            bricks.forEach(b => b.y += 45);
            spawnBricks(40);
            if (bricks.some(b => b.y + b.h > height / 2)) {
                isGameOver = true;
                gameOverScreen.style.display = 'block';
            }
        }
        launchEl.innerText = launchCount;
    }
});

gameOverScreen.addEventListener('click', initGame);

function update() {
    if (isGameOver) return requestAnimationFrame(update);
    waveTime += 0.03;

    // 更新粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        if (p.type === 'explode') p.vy += 0.1; 
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }

    balls = balls.filter(ball => {
        ball.vy += 0.28;
        ball.x += ball.vx;
        ball.y += ball.vy;

        // 小球拖尾特效
        if (Math.random() > 0.3) spawnParticles(ball.x, ball.y, `hsla(${ball.hue}, 100%, 70%, 0.5)`, 'trail', 1);

        if (ball.y >= height / 2) {
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > width) {
                ball.vx *= -0.9;
                ball.x = ball.x < 0 ? ball.radius : width - ball.radius;
                spawnParticles(ball.x, ball.y, '#00f2ff', 'explode', 5);
            }
        } else {
            if (ball.x < 0 || ball.x > width) {
                playBassNote(100);
                spawnParticles(ball.x, ball.y, 'rgba(255,255,255,0.3)', 'explode', 20); // 消失也用explode
                return false;
            }
        }

        const sY = getStringY(ball.x);
        if (ball.y + ball.radius > sY && ball.vy > 0) {
            ball.y = sY - ball.radius - 2;
            const slope = (getStringY(ball.x + 2) - getStringY(ball.x - 2)) / 4;
            ball.vx += slope * 10 + (Math.random() - 0.5) * 5;
            ball.vy = -16 - Math.random() * 3; 
            playBassNote(80);
            spawnParticles(ball.x, ball.y, '#00f2ff', 'explode', 15);
        }

        for (let i = bricks.length - 1; i >= 0; i--) {
            const b = bricks[i];
            if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                playPianoNote(ball.x);
                // *** 核心改动：在背景痕迹画布上绘制痕迹 ***
                traceCtx.fillStyle = b.color;
                traceCtx.globalAlpha = 0.3; // 半透明
                traceCtx.fillRect(b.x, b.y, b.w, b.h);
                traceCtx.globalAlpha = 1.0;

                spawnParticles(b.x + b.w/2, b.y + b.h/2, b.color, 'explode', 20);
                bricks.splice(i, 1);
                ball.vy *= -1.05;
                score += 100;
                scoreEl.innerText = score;
            }
        }
        return ball.y < height + 100;
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    // 1. 先用带有少量透明度的填充清空主画布，产生残影效果
    ctx.fillStyle = 'rgba(2, 2, 5, 0.3)';
    ctx.fillRect(0, 0, width, height);

    // 2. 将背景痕迹画布绘制到主画布上（会自然叠加残影）
    ctx.drawImage(traceCanvas, 0, 0);

    // 3. 绘制消失区阴影
    ctx.fillStyle = 'rgba(0, 242, 255, 0.02)';
    ctx.fillRect(0, 0, width, height / 2);

    // 4. 绘制下半屏边界能量
    const glow = 0.3 + Math.sin(waveTime * 3) * 0.1;
    ctx.fillStyle = `rgba(0, 242, 255, ${glow})`;
    ctx.fillRect(0, height/2, 5, height/2);
    ctx.fillRect(width-5, height/2, 5, height/2);

    // 5. 绘制粒子
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        if (p.type === 'trail') {
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
        } else {
            ctx.fillRect(p.x, p.y, p.size, p.size);
        }
        ctx.fill();
    });
    ctx.globalAlpha = 1.0;

    // 6. 绘制波浪琴弦
    ctx.shadowBlur = 20; ctx.shadowColor = '#00f2ff';
    ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 4;
    ctx.beginPath();
    for(let x = 0; x <= width; x += 10) {
        const y = getStringY(x);
        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;

    // 7. 砖块
    bricks.forEach(b => {
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.strokeRect(b.x, b.y, b.w, b.h);
    });

    // 8. 小球
    balls.forEach(ball => {
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 10; ctx.shadowColor = '#00f2ff';
        ctx.fillStyle = '#00f2ff';
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius/1.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    });
}

initGame();
update();
</script>
</body>
</html>
