<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>打砖块</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010103; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00f2ff;
            pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0,242,255,0.7);
        }
        .stat { font-size: 24px; font-weight: bold; font-variant-numeric: tabular-nums; }
        #gameOver {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: 48px; font-weight: bold; text-align: center;
            display: none; background: rgba(0,0,0,0.95); padding: 40px; border: 1px solid #ff3333;
            box-shadow: 0 0 50px rgba(255,0,0,0.3); z-index: 100; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat">SCORE: <span id="score">0</span></div>
        <div class="stat">LAUNCH: <span id="launchCount">0</span>/3</div>
        <div style="font-size: 12px; color: #0088ff; margin-top: 5px; opacity: 0.8;">
            ✦ 每发出三个小球，砖块下降一格 ✦
        </div>
    </div>
    <div id="gameOver">GAME OVER<br><span style="font-size: 20px; color: #fff;">点击重启</span></div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const launchEl = document.getElementById('launchCount');
const gameOverScreen = document.getElementById('gameOver');

// 背景痕迹层
const traceCanvas = document.createElement('canvas');
const traceCtx = traceCanvas.getContext('2d');

let width, height, score = 0, launchCount = 0, isGameOver = false;
let balls = [], bricks = [], particles = [];
let waveTime = 0;
// 存储每列专属色相，确保列间颜色唯一
let columnHues = [];

let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playPianoNote(x) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const freq = 130.81 + (x / width) * 700; 
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 1.2);
}

function playBassNote(freq) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.5);
}

// 强化版爆炸粒子：高密度、高速度、大尺寸、慢衰减
function spawnParticles(x, y, color, type = 'explode', count = 30) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = type === 'trail' ? Math.random() * 2 : Math.random() * 8 + 12;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: type === 'trail' ? 0.05 : Math.random() * 0.005 + 0.003,
            size: type === 'trail' ? 1.5 : Math.random() * 4 + 4,
            rot: Math.random() * Math.PI,
            vRot: (Math.random() - 0.5) * 0.2,
            color,
            type 
        });
    }
}

// 超广域水墨残留：3倍扩散范围、四层晕染、自然浓度衰减、全画布弥散
function drawSplatter(x, y, color) {
    traceCtx.save();
    // 基础透明度：兼顾浓郁度与通透感，适配广域扩散
    traceCtx.globalAlpha = 0.3;
    // 解析砖块HSL颜色，转化为水墨低饱和基色
    const colorMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
    const hue = colorMatch ? colorMatch[1] : 200;
    const baseSaturation = colorMatch ? parseInt(colorMatch[2]) * 0.55 : 35; // 更低饱和度，贴合水墨质感
    const baseLightness = colorMatch ? parseInt(colorMatch[3]) * 0.65 : 45;  // 微调亮度，提升层次对比

    // 1. 核心浓墨层：超大尺寸径向渐变，广域晕染主体（原范围2.5倍）
    const coreGradient = traceCtx.createRadialGradient(x, y, 0, x, y, 200);
    coreGradient.addColorStop(0, `hsl(${hue}, ${baseSaturation + 25}%, ${baseLightness - 15}%)`); // 中心极浓
    coreGradient.addColorStop(0.4, `hsl(${hue}, ${baseSaturation + 10}%, ${baseLightness - 5}%)`); // 中层浓
    coreGradient.addColorStop(0.7, `hsl(${hue}, ${baseSaturation}%, ${baseLightness}%)`); // 外层过渡
    coreGradient.addColorStop(1, 'rgba(0,0,0,0)'); // 边缘完全虚化，融入背景
    traceCtx.fillStyle = coreGradient;
    traceCtx.beginPath();
    traceCtx.arc(x, y, 200, 0, Math.PI * 2);
    traceCtx.fill();

    // 2. 中墨点层：大小错落，中等浓度，广域扩散（原范围3倍）
    for (let i = 0; i < 40; i++) {
        const ox = (Math.random() - 0.5) * 360; // 左右扩散±360px
        const oy = (Math.random() - 0.5) * 270; // 上下扩散±270px
        const r = Math.random() * 18 + 4; // 墨点半径4-22px，大小更丰富
        // 距离衰减：离中心越远越淡，最远250px外完全透明
        const distance = Math.sqrt(ox * ox + oy * oy);
        const dotAlpha = 0.3 - (distance / 250);
        if (dotAlpha <= 0) continue;

        traceCtx.globalAlpha = dotAlpha;
        const dotHue = hue + (Math.random() - 0.5) * 20; // 色相微偏移，提升纹理感
        traceCtx.fillStyle = `hsl(${dotHue}, ${baseSaturation - 5}%, ${baseLightness + 8}%)`;
        traceCtx.beginPath();
        traceCtx.arc(x + ox, y + oy, r, 0, Math.PI * 2);
        traceCtx.fill();
    }

    // 3. 淡墨弥散层：超大尺寸，低浓度，超广域扩散（原范围3.5倍）
    traceCtx.globalAlpha = 0.15;
    traceCtx.fillStyle = `hsl(${hue}, ${baseSaturation - 15}%, ${baseLightness + 12}%)`;
    for (let i = 0; i < 25; i++) {
        const r = Math.random() * 35 + 15; // 大尺寸墨点15-50px
        const ox = (Math.random() - 0.5) * 540; // 左右超广扩散±540px
        const oy = (Math.random() - 0.5) * 420; // 上下超广扩散±420px
        traceCtx.beginPath();
        traceCtx.arc(x + ox, y + oy, r, 0, Math.PI * 2);
        traceCtx.fill();
    }

    // 4. 极淡墨雾层：全画布弥散，营造水墨缥缈感（新增层）
    traceCtx.globalAlpha = 0.08;
    traceCtx.fillStyle = `hsl(${hue}, ${baseSaturation - 25}%, ${baseLightness + 18}%)`;
    for (let i = 0; i < 15; i++) {
        const r = Math.random() * 50 + 20; // 超大墨点20-70px
        const ox = (Math.random() - 0.5) * 720; // 极限扩散±720px
        const oy = (Math.random() - 0.5) * 560; // 极限扩散±560px
        traceCtx.beginPath();
        traceCtx.arc(x + ox, y + oy, r, 0, Math.PI * 2);
        traceCtx.fill();
    }

    traceCtx.restore();
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    traceCanvas.width = width;
    traceCanvas.height = height;
    traceCtx.clearRect(0, 0, width, height);
    // 重新计算列数并生成每列专属色相，窗口缩放后保持列色唯一
    const cols = Math.floor(width / 100);
    columnHues = [];
    const hueStep = 360 / cols; // 平均分配360°色相环，列间无重复
    for (let i = 0; i < cols; i++) {
        columnHues.push(Math.floor(i * hueStep)); // 存储整数色相，避免精度问题
    }
}
window.addEventListener('resize', resize);
resize();

// 每列砖块使用专属色相，同列砖块颜色一致，列间颜色唯一
function spawnBricks(y = 50, density = 0.75) {
    const cols = Math.floor(width / 100);
    const bW = (width - 40) / cols;
    // 确保列色相数组长度匹配当前列数
    if (columnHues.length !== cols) resize();
    for (let i = 0; i < cols; i++) {
        if (Math.random() > density) {
            const colHue = columnHues[i]; // 取当前列专属色相
            bricks.push({
                x: 20 + i * bW, y: y,
                w: bW - 15, h: 25,
                baseHue: colHue, // 存储列专属色相
                // 固定饱和度80%、亮度65%，仅色相随列变化，色彩统一且区分明显
                color: `hsl(${colHue}, 80%, 65%)`
            });
        }
    }
}

function initGame() {
    score = 0; launchCount = 0; isGameOver = false;
    balls = []; bricks = []; particles = [];
    scoreEl.innerText = "0"; launchEl.innerText = "0";
    gameOverScreen.style.display = 'none';
    traceCtx.clearRect(0, 0, width, height);
    // 初始生成3行砖块，均使用列专属配色
    for(let i = 0; i < 3; i++) spawnBricks(80 + i * 45, 0.8);
}

function getStringY(x) {
    const xPos = x / width * 3.5;
    return height * 0.86 + Math.sin(xPos + waveTime * 0.25) * 20 + Math.cos(xPos * 0.7 - waveTime * 0.15) * 15;
}

canvas.addEventListener('mousedown', (e) => {
    initAudio();
    if (isGameOver) return;
    if (e.clientY > height / 2) {
        balls.push({ x: e.clientX, y: e.clientY, vx: (Math.random()-0.5)*3, vy: 9, radius: 8, hue: Math.random()*360 });
        launchCount++;
        playBassNote(300);
        if (launchCount >= 3) {
            launchCount = 0;
            bricks.forEach(b => b.y += 50);
            spawnBricks(50, 0.7);
            if (bricks.some(b => b.y + b.h > height / 2)) {
                isGameOver = true;
                gameOverScreen.style.display = 'block';
            }
        }
        launchEl.innerText = launchCount;
    }
});

gameOverScreen.addEventListener('click', initGame);

function update() {
    if (isGameOver) return requestAnimationFrame(update);
    waveTime += 0.02; 

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.rot += p.vRot;
        if (p.type === 'explode') { 
            p.vy += 0.12;
            p.vx *= 0.98;
        }
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }

    balls = balls.filter(ball => {
        ball.vy += 0.28; ball.x += ball.vx; ball.y += ball.vy;

        if (Math.random() > 0.5) spawnParticles(ball.x, ball.y, `hsla(${ball.hue}, 100%, 80%, 0.3)`, 'trail', 1);

        if (ball.y >= height / 2) {
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > width) {
                ball.vx *= -0.8;
                ball.x = ball.x < 0 ? ball.radius : width - ball.radius;
            }
        } else if (ball.x < 0 || ball.x > width) return false;

        const sY = getStringY(ball.x);
        if (ball.y + ball.radius > sY && ball.vy > 0) {
            ball.y = sY - ball.radius - 2;
            ball.vx += (getStringY(ball.x+2)-getStringY(ball.x-2)) * 4;
            ball.vy = -16 - Math.random() * 2; 
            playBassNote(70);
            spawnParticles(ball.x, ball.y, '#00f2ff', 'explode', 8);
        }

        for (let i = bricks.length - 1; i >= 0; i--) {
            const b = bricks[i];
            if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                playPianoNote(ball.x);
                drawSplatter(b.x + b.w/2, b.y + b.h/2, b.color);
                spawnParticles(b.x + b.w/2, b.y + b.h/2, b.color, 'explode', 90);
                bricks.splice(i, 1);
                ball.vy *= -1.03;
                score += 100; scoreEl.innerText = score;
            }
        }
        return ball.y < height + 100;
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.fillStyle = 'rgba(1, 1, 3, 0.3)';
    ctx.fillRect(0, 0, width, height);
    ctx.drawImage(traceCanvas, 0, 0);

    // 1. 绘制生死分界线
    ctx.setLineDash([10, 15]);
    ctx.strokeStyle = 'rgba(255, 50, 50, 0.25)';
    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    ctx.lineTo(width, height / 2);
    ctx.stroke();
    ctx.setLineDash([]);

    // 2. 绘制下半屏两侧标识（能量柱）
    const glow = 0.2 + Math.sin(waveTime) * 0.1;
    ctx.fillStyle = `rgba(0, 242, 255, ${glow})`;
    ctx.fillRect(0, height / 2, 4, height / 2);
    ctx.fillRect(width - 4, height / 2, 4, height / 2);

    // 3. 粒子绘制
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        if (p.type === 'explode') {
            ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
        } else {
            ctx.beginPath(); ctx.arc(0, 0, p.size, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    });
    ctx.globalAlpha = 1.0;

    // 4. 绘制琴弦
    ctx.shadowBlur = 15; ctx.shadowColor = '#00f2ff';
    ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 3;
    ctx.beginPath();
    for(let x = 0; x <= width; x += 10) {
        const y = getStringY(x);
        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;

    // 5. 绘制砖块 (极慢流光边框，保留列专属色流光)
    bricks.forEach(b => {
        const flowOffset = (waveTime * 0.1) % 1; 
        const gradient = ctx.createLinearGradient(b.x - b.w, b.y, b.x + b.w * 2, b.y + b.h);
        gradient.addColorStop(flowOffset, b.color);
        gradient.addColorStop((flowOffset + 0.2) % 1, '#fff');
        gradient.addColorStop((flowOffset + 0.4) % 1, b.color);

        ctx.fillStyle = 'rgba(5, 5, 15, 0.95)';
        ctx.fillRect(b.x, b.y, b.w, b.h);

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = b.color;
        ctx.strokeRect(b.x, b.y, b.w, b.h);
        ctx.shadowBlur = 0;
    });

    // 6. 小球
    balls.forEach(ball => {
        ctx.shadowBlur = 15; ctx.shadowColor = `hsla(${ball.hue}, 100%, 50%, 0.6)`;
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    });
}

initGame();
update();
</script>
</body>
</html>
