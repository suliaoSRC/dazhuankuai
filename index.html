<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>赛博钢琴 - 碎裂爆发版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010103; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00f2ff;
            pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0,242,255,0.7);
        }
        .stat { font-size: 24px; font-weight: bold; font-variant-numeric: tabular-nums; }
        #gameOver {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: 48px; font-weight: bold; text-align: center;
            display: none; background: rgba(0,0,0,0.95); padding: 40px; border: 1px solid #ff3333;
            box-shadow: 0 0 50px rgba(255,0,0,0.3); z-index: 100; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat">SCORE: <span id="score">0</span></div>
        <div class="stat">LAUNCH: <span id="launchCount">0</span>/3</div>
        <div style="font-size: 12px; color: #0088ff; margin-top: 5px;">碎裂反馈已增强 | 钢琴音阶映射</div>
    </div>
    <div id="gameOver">GAME OVER<br><span style="font-size: 20px; color: #fff;">点击重启</span></div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const launchEl = document.getElementById('launchCount');
const gameOverScreen = document.getElementById('gameOver');

// 背景痕迹画布
const traceCanvas = document.createElement('canvas');
const traceCtx = traceCanvas.getContext('2d');

let width, height, score = 0, launchCount = 0, isGameOver = false;
let balls = [], bricks = [], particles = [];
let waveTime = 0;

// 音频初始化
let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playPianoNote(x) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const freq = 130.81 + (x / width) * 880; // C3 - A5
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 1.2);
}

function playBassNote(freq) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.5);
}

// 极其夸张的粒子生成器
function spawnParticles(x, y, color, type = 'explode', count = 35) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = type === 'trail' ? Math.random() * 3 : Math.random() * 12 + 2;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: type === 'trail' ? 0.05 : Math.random() * 0.01 + 0.01,
            size: type === 'trail' ? 2 : Math.random() * 5 + 2,
            rot: Math.random() * Math.PI,
            vRot: (Math.random() - 0.5) * 0.2,
            color,
            type 
        });
    }
}

// 在背景上绘制碎裂喷溅痕迹
function drawSplatter(x, y, color) {
    traceCtx.save();
    traceCtx.globalAlpha = 0.4;
    traceCtx.fillStyle = color;
    // 绘制多个随机圆点和碎片模拟喷溅
    for (let i = 0; i < 8; i++) {
        const r = Math.random() * 15 + 5;
        const ox = (Math.random() - 0.5) * 40;
        const oy = (Math.random() - 0.5) * 20;
        traceCtx.beginPath();
        traceCtx.arc(x + ox, y + oy, r, 0, Math.PI * 2);
        traceCtx.fill();
    }
    traceCtx.restore();
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    traceCanvas.width = width;
    traceCanvas.height = height;
    traceCtx.clearRect(0, 0, width, height); 
}
window.addEventListener('resize', resize);
resize();

function spawnBricks(y = 50) {
    const cols = Math.floor(width / 95);
    const bW = (width - 40) / cols;
    for (let i = 0; i < cols; i++) {
        if (Math.random() > 0.55) {
            bricks.push({
                x: 20 + i * bW, y: y,
                w: bW - 12, h: 24,
                color: `hsl(${i * (360/cols)}, 80%, 65%)`,
                hue: i * (360/cols)
            });
        }
    }
}

function initGame() {
    score = 0; launchCount = 0; isGameOver = false;
    balls = []; bricks = []; particles = [];
    scoreEl.innerText = "0"; launchEl.innerText = "0";
    gameOverScreen.style.display = 'none';
    traceCtx.clearRect(0, 0, width, height);
    for(let i = 0; i < 4; i++) spawnBricks(60 + i * 45);
}

function getStringY(x) {
    const xPos = x / width * 4;
    const wave1 = Math.sin(xPos + waveTime * 0.4) * 25;
    const wave2 = Math.cos(xPos * 0.8 - waveTime * 0.3) * 15;
    return height * 0.86 + wave1 + wave2;
}

canvas.addEventListener('mousedown', (e) => {
    initAudio();
    if (isGameOver) return;
    if (e.clientY > height / 2) {
        balls.push({ x: e.clientX, y: e.clientY, vx: (Math.random()-0.5)*3, vy: 9, radius: 9, hue: Math.random()*360 });
        launchCount++;
        playBassNote(400);
        spawnParticles(e.clientX, e.clientY, '#00f2ff', 'explode', 10);
        if (launchCount >= 3) {
            launchCount = 0;
            bricks.forEach(b => b.y += 50);
            spawnBricks(40);
            if (bricks.some(b => b.y + b.h > height / 2)) {
                isGameOver = true;
                gameOverScreen.style.display = 'block';
            }
        }
        launchEl.innerText = launchCount;
    }
});

gameOverScreen.addEventListener('click', initGame);

function update() {
    if (isGameOver) return requestAnimationFrame(update);
    waveTime += 0.035;

    // 更新粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.rot += p.vRot;
        if (p.type === 'explode') {
            p.vy += 0.15; // 碎裂重力
            p.vx *= 0.98; // 空气摩擦
        }
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }

    balls = balls.filter(ball => {
        ball.vy += 0.3;
        ball.x += ball.vx;
        ball.y += ball.vy;

        if (Math.random() > 0.4) spawnParticles(ball.x, ball.y, `hsla(${ball.hue}, 100%, 75%, 0.6)`, 'trail', 1);

        // 边界碰撞
        if (ball.y >= height / 2) {
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > width) {
                ball.vx *= -0.95;
                ball.x = ball.x < 0 ? ball.radius : width - ball.radius;
            }
        } else if (ball.x < 0 || ball.x > width) {
            playBassNote(120);
            return false;
        }

        // 琴弦反弹
        const sY = getStringY(ball.x);
        if (ball.y + ball.radius > sY && ball.vy > 0) {
            ball.y = sY - ball.radius - 2;
            const slope = (getStringY(ball.x + 3) - getStringY(ball.x - 3)) / 6;
            ball.vx += slope * 12 + (Math.random() - 0.5) * 6;
            ball.vy = -17 - Math.random() * 3; 
            playBassNote(85);
            spawnParticles(ball.x, ball.y, '#00f2ff', 'explode', 12);
        }

        // 砖块碰撞
        for (let i = bricks.length - 1; i >= 0; i--) {
            const b = bricks[i];
            if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                playPianoNote(ball.x);
                // 绘制背景喷溅痕迹
                drawSplatter(b.x + b.w/2, b.y + b.h/2, b.color);
                // 产生极其夸张的碎片
                spawnParticles(b.x + b.w/2, b.y + b.h/2, b.color, 'explode', 45);
                bricks.splice(i, 1);
                ball.vy *= -1.06;
                score += 100;
                scoreEl.innerText = score;
            }
        }
        return ball.y < height + 100;
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    // 尾迹清理
    ctx.fillStyle = 'rgba(1, 1, 3, 0.25)';
    ctx.fillRect(0, 0, width, height);

    // 绘制痕迹层
    ctx.drawImage(traceCanvas, 0, 0);

    // 消失区提示
    ctx.fillStyle = 'rgba(0, 242, 255, 0.015)';
    ctx.fillRect(0, 0, width, height / 2);

    // 粒子绘制
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        if (p.type === 'trail') {
            ctx.beginPath();
            ctx.arc(0, 0, p.size * p.life, 0, Math.PI*2);
            ctx.fill();
        } else {
            // 碎裂碎片绘制为不规则方块
            ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
        }
        ctx.restore();
    });
    ctx.globalAlpha = 1.0;

    // 波浪琴弦
    ctx.shadowBlur = 20; ctx.shadowColor = '#00f2ff';
    ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 4;
    ctx.beginPath();
    for(let x = 0; x <= width; x += 8) {
        const y = getStringY(x);
        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;

    // 酷炫砖块绘制
    bricks.forEach(b => {
        // 呼吸效果
        const pulse = 0.5 + Math.sin(waveTime * 5 + b.hue) * 0.5;
        
        // 1. 填充内部（暗色）
        ctx.fillStyle = 'rgba(15, 15, 25, 0.8)';
        ctx.fillRect(b.x, b.y, b.w, b.h);
        
        // 2. 酷炫边框
        ctx.strokeStyle = b.color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5 + pulse * 10;
        ctx.shadowColor = b.color;
        ctx.strokeRect(b.x, b.y, b.w, b.h);
        
        // 3. 四角装饰点
        ctx.fillStyle = b.color;
        const s = 3;
        ctx.fillRect(b.x-1, b.y-1, s, s);
        ctx.fillRect(b.x+b.w-s+1, b.y-1, s, s);
        ctx.fillRect(b.x-1, b.y+b.h-s+1, s, s);
        ctx.fillRect(b.x+b.w-s+1, b.y+b.h-s+1, s, s);
        ctx.shadowBlur = 0;
    });

    // 小球
    balls.forEach(ball => {
        ctx.shadowBlur = 15; ctx.shadowColor = `hsla(${ball.hue}, 100%, 50%, 0.8)`;
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    });
}

initGame();
update();
</script>
</body>
</html>
