<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>打砖块-手机版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010103; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px; color: #00f2ff; /* 恢复左定位，移除居中偏移 */
            pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0,242,255,0.7);
            text-align: left; /* 强制文字居左 */
            z-index: 5;
        }
        .stat { font-size: clamp(18px, 5vw, 24px); font-weight: bold; font-variant-numeric: tabular-nums; margin: 2px 0; }
        #gameOver {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: clamp(32px, 10vw, 48px); font-weight: bold; text-align: center; /* 游戏结束弹窗保持居中，体验更佳 */
            display: none; background: rgba(0,0,0,0.95); padding: 30px 20px; border: 1px solid #ff3333;
            box-shadow: 0 0 50px rgba(255,0,0,0.3); z-index: 100; cursor: pointer;
            border-radius: 10px;
            width: 80%; max-width: 400px;
        }
        #gameOver span { font-size: clamp(16px, 4vw, 20px); color: #fff; display: block; margin-top: 15px; }
        .tip { font-size: clamp(10px, 3vw, 12px); color: #ff00ff; margin-top: 5px; opacity: 0.9; letter-spacing: 1px; }
        /* 手机触控区域提示 - 居左对齐，与主UI保持一致 */
        #touchHint {
            position: absolute; bottom: 20px; left: 10px; /* 恢复左定位，移除居中偏移 */
            color: rgba(0,242,255,0.6); font-size: clamp(12px, 4vw, 14px);
            pointer-events: none; user-select: none;
            text-shadow: 0 0 8px rgba(0,242,255,0.5);
            text-align: left; /* 强制居左 */
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat">SCORE: <span id="score">0</span></div>
        <div class="stat">LAUNCH: <span id="launchCount">0</span>/3</div>
        <div class="tip">✦ 每发射三个小球，砖块下降一格✦</div>
    </div>
    <div id="gameOver">GAME OVER<br><span>点击/触摸重启</span></div>
    <div id="touchHint">点击屏幕下方发射小球</div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const launchEl = document.getElementById('launchCount');
const gameOverScreen = document.getElementById('gameOver');

const traceCanvas = document.createElement('canvas');
const traceCtx = traceCanvas.getContext('2d');

let width, height, score = 0, launchCount = 0, isGameOver = false;
let balls = [], bricks = [], particles = [];
let waveTime = 0;
let columnHues = []; // 存储每列专属色相

let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playPianoNote(x) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const freq = 130 + (x / width) * 700; 
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 1.2);
}

function playBassNote(freq) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.6);
}

function spawnParticles(x, y, color, type = 'explode', count = 30) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = type === 'trail' ? Math.random() * 2 : Math.random() * 10 + 5;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: type === 'trail' ? 0.05 : Math.random() * 0.006 + 0.004,
            size: type === 'trail' ? 2 : Math.random() * 5 + 3,
            rot: Math.random() * Math.PI,
            vRot: (Math.random() - 0.5) * 0.2,
            color,
            type 
        });
    }
}

// 广域水墨残留：分层晕染，广度大幅提升
function drawInkSplatter(x, y, color) {
    traceCtx.save();
    const colorMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
    const hue = colorMatch ? colorMatch[1] : 200;

    // 1. 核心浓墨层
    traceCtx.globalAlpha = 0.35;
    const grad = traceCtx.createRadialGradient(x, y, 0, x, y, 150);
    grad.addColorStop(0, `hsla(${hue}, 80%, 40%, 0.6)`);
    grad.addColorStop(1, `hsla(${hue}, 80%, 40%, 0)`);
    traceCtx.fillStyle = grad;
    traceCtx.beginPath();
    traceCtx.arc(x, y, 150, 0, Math.PI * 2);
    traceCtx.fill();

    // 2. 广域喷溅墨点
    for (let i = 0; i < 45; i++) {
        const ang = Math.random() * Math.PI * 2;
        const dist = Math.random() * 400; // 扩散半径增加到400
        const r = Math.random() * 15 + 2;
        const alpha = Math.max(0, 0.3 - (dist/400));
        traceCtx.globalAlpha = alpha;
        traceCtx.fillStyle = color;
        traceCtx.beginPath();
        traceCtx.arc(x + Math.cos(ang)*dist, y + Math.sin(ang)*dist, r, 0, Math.PI * 2);
        traceCtx.fill();
    }

    // 3. 缥缈墨痕
    traceCtx.globalAlpha = 0.05;
    for(let i=0; i<10; i++) {
        const r = Math.random() * 80 + 20;
        const ox = (Math.random()-0.5) * 600;
        const oy = (Math.random()-0.5) * 400;
        traceCtx.beginPath();
        traceCtx.arc(x + ox, y + oy, r, 0, Math.PI * 2);
        traceCtx.fill();
    }
    traceCtx.restore();
}

function resize() {
    // 适配手机屏幕，强制占满可视区域
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    traceCanvas.width = width;
    traceCanvas.height = height;
    
    const cols = Math.floor(width / 60); // 手机端减少砖块列宽，增加列数，适配窄屏
    columnHues = [];
    for (let i = 0; i < cols; i++) {
        columnHues.push(Math.floor((i * 360 / cols) % 360));
    }
}
// 监听窗口大小变化，适配横竖屏切换
window.addEventListener('resize', resize);
// 解决手机旋转后尺寸未更新问题
window.addEventListener('orientationchange', () => {
    setTimeout(resize, 100);
});
resize();

function spawnBricks(y = 50, density = 0.8) {
    const cols = Math.floor(width / 60); // 手机端砖块宽度适配
    const bW = (width - 30) / cols; // 减少左右边距，适配窄屏
    for (let i = 0; i < cols; i++) {
        if (Math.random() > density) {
            const h = columnHues[i];
            bricks.push({
                x: 15 + i * bW, y: y, // 减少左边距
                w: bW - 10, h: 22, // 缩小砖块高度，适配手机竖屏
                color: `hsl(${h}, 80%, 65%)`
            });
        }
    }
}

function initGame() {
    score = 0; launchCount = 0; isGameOver = false;
    balls = []; bricks = []; particles = [];
    scoreEl.innerText = "0"; launchEl.innerText = "0";
    gameOverScreen.style.display = 'none';
    traceCtx.clearRect(0, 0, width, height);
    // 手机端减少初始砖块行数，降低竖屏压力
    for(let i = 0; i < 2; i++) spawnBricks(60 + i * 40, 0.85);
}

function getStringY(x) {
    const xPos = x / width * 3.5;
    // 手机端下调琴弦位置，增加发射操作区域
    return height * 0.88 + Math.sin(xPos + waveTime * 0.25) * 15 + Math.cos(xPos * 0.7 - waveTime * 0.15) * 10;
}

// 同时适配鼠标点击和手机触摸
function handleLaunch(e) {
    initAudio();
    if (isGameOver) return;
    // 获取触摸/点击的坐标，兼容触摸事件和鼠标事件
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    // 手机端扩大发射区域（屏幕下半部分），提升操作容错
    if (clientY > height * 0.4) {
        // 手机端优化小球初速度，减少左右偏移，提升操控性
        balls.push({ x: clientX, y: clientY, vx: (Math.random()-0.5)*2, vy: 8, radius: 7, hue: Math.random()*360 });
        launchCount++;
        playBassNote(200);
        if (launchCount >= 3) {
            launchCount = 0;
            // 手机端减少砖块下降距离，降低游戏难度
            bricks.forEach(b => b.y += 40);
            spawnBricks(50, 0.75);
            // 手机端调整游戏结束判定线，适配琴弦位置
            if (bricks.some(b => b.y + b.h > height * 0.45)) {
                isGameOver = true;
                gameOverScreen.style.display = 'block';
            }
        }
        launchEl.innerText = launchCount;
    }
    // 阻止触摸事件默认行为，防止页面滚动
    e.preventDefault();
}

// 绑定鼠标和触摸事件
canvas.addEventListener('mousedown', handleLaunch);
canvas.addEventListener('touchstart', handleLaunch);
// 游戏结束重启适配触摸
gameOverScreen.addEventListener('click', initGame);
gameOverScreen.addEventListener('touchstart', (e) => {
    initGame();
    e.preventDefault();
});

function update() {
    if (isGameOver) return requestAnimationFrame(update);
    waveTime += 0.02;

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vy += 0.12; // 手机端减少粒子重力，提升视觉效果
        p.vx *= 0.985;
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }

    balls = balls.filter(ball => {
        ball.vy += 0.25; // 手机端减少小球重力，提升弹跳体验
        ball.x += ball.vx; ball.y += ball.vy;

        if (ball.y >= height * 0.4) { // 手机端碰撞边界调整
            if (ball.x < 0 || ball.x > width) {
                ball.vx *= -0.8; // 减少反弹速度损失，提升连贯性
                ball.x = ball.x < 0 ? 0 : width;
            }
        } else if (ball.x < 0 || ball.x > width) return false;

        const sY = getStringY(ball.x);
        if (ball.y + ball.radius > sY && ball.vy > 0) {
            ball.y = sY - ball.radius; 
            ball.vy = -20; // 手机端降低琴弦反弹力度，适配竖屏
            playBassNote(60);
            // 触摸反馈：小球撞击琴弦时震动（手机端）
            if (window.navigator.vibrate) {
                window.navigator.vibrate(50);
            }
        }

        bricks.forEach((b, i) => {
            if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                playPianoNote(ball.x);
                drawInkSplatter(b.x + b.w/2, b.y + b.h/2, b.color);
                spawnParticles(b.x + b.w/2, b.y + b.h/2, b.color, 'explode', 50); // 减少粒子数量，提升手机性能
                bricks.splice(i, 1);
                ball.vy *= -1.03; // 轻微提升反弹力度
                score += 100; scoreEl.innerText = score;
                // 触摸反馈：击碎砖块时短震动（手机端）
                if (window.navigator.vibrate) {
                    window.navigator.vibrate(30);
                }
            }
        });
        return ball.y < height + 80; // 缩短小球存活距离
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.fillStyle = 'rgba(1, 1, 3, 0.35)';
    ctx.fillRect(0, 0, width, height);
    ctx.drawImage(traceCanvas, 0, 0);

    // 生死线 - 手机端上移，适配操作区域
    ctx.setLineDash([8, 12]);
    ctx.strokeStyle = 'rgba(255, 50, 50, 0.3)';
    ctx.beginPath(); ctx.moveTo(0, height*0.45); ctx.lineTo(width, height*0.45); ctx.stroke();
    ctx.setLineDash([]);

    // 侧边能量 - 手机端变窄，适配窄屏
    const glow = 0.2 + Math.sin(waveTime) * 0.1;
    ctx.fillStyle = `rgba(0, 242, 255, ${glow})`;
    ctx.fillRect(0, height*0.45, 3, height*0.55);
    ctx.fillRect(width-3, height*0.45, 3, height*0.55);

    // 粒子
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    ctx.globalAlpha = 1;

    // 砖块 - 极慢流光
    bricks.forEach(b => {
        const flow = (waveTime * 0.08) % 1;
        const grad = ctx.createLinearGradient(b.x, b.y, b.x + b.w, b.y + b.h);
        grad.addColorStop(flow, b.color);
        grad.addColorStop((flow + 0.15)%1, '#fff');
        grad.addColorStop((flow + 0.3)%1, b.color);

        ctx.fillStyle = 'rgba(5, 5, 15, 0.9)';
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2; // 手机端减少描边宽度，更精致
        ctx.strokeRect(b.x, b.y, b.w, b.h);
    });

    // 琴弦 - 手机端变细，适配屏幕
    ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 3;
    ctx.beginPath();
    for(let x=0; x<=width; x+=8) { // 减少采样点，提升手机性能
        const y = getStringY(x);
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // 小球 - 手机端优化绘制，增加轻微描边提升辨识度
    balls.forEach(ball => {
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        // 小球外描边，手机端更易看清
        ctx.strokeStyle = `hsl(${ball.hue}, 80%, 50%)`;
        ctx.lineWidth = 1;
        ctx.stroke();
    });
}

// 初始化游戏
initGame();
update();

// 页面加载完成后解锁音频（解决手机端音频自动播放限制）
document.addEventListener('click', initAudio, { once: true });
document.addEventListener('touchstart', initAudio, { once: true });
</script>
</body>
</html>
