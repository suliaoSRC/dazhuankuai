<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>赛博钢琴 - 水墨霓虹广域版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010103; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00f2ff;
            pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0,242,255,0.7);
        }
        .stat { font-size: 24px; font-weight: bold; font-variant-numeric: tabular-nums; }
        #gameOver {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: 48px; font-weight: bold; text-align: center;
            display: none; background: rgba(0,0,0,0.95); padding: 40px; border: 1px solid #ff3333;
            box-shadow: 0 0 50px rgba(255,0,0,0.3); z-index: 100; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stat">SCORE: <span id="score">0</span></div>
        <div class="stat">LAUNCH: <span id="launchCount">0</span>/3</div>
        <div style="font-size: 12px; color: #ff00ff; margin-top: 5px; opacity: 0.9; letter-spacing: 1px;">
            ✦ 矩阵列色 | 广域水墨扩散 | 动感反馈 ✦
        </div>
    </div>
    <div id="gameOver">GAME OVER<br><span style="font-size: 20px; color: #fff;">点击重启</span></div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const launchEl = document.getElementById('launchCount');
const gameOverScreen = document.getElementById('gameOver');

const traceCanvas = document.createElement('canvas');
const traceCtx = traceCanvas.getContext('2d');

let width, height, score = 0, launchCount = 0, isGameOver = false;
let balls = [], bricks = [], particles = [];
let waveTime = 0;
let columnHues = []; // 存储每列专属色相

let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playPianoNote(x) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const freq = 130 + (x / width) * 700; 
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 1.2);
}

function playBassNote(freq) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.6);
}

function spawnParticles(x, y, color, type = 'explode', count = 30) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = type === 'trail' ? Math.random() * 2 : Math.random() * 10 + 5;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: type === 'trail' ? 0.05 : Math.random() * 0.006 + 0.004,
            size: type === 'trail' ? 2 : Math.random() * 5 + 3,
            rot: Math.random() * Math.PI,
            vRot: (Math.random() - 0.5) * 0.2,
            color,
            type 
        });
    }
}

// 广域水墨残留：分层晕染，广度大幅提升
function drawInkSplatter(x, y, color) {
    traceCtx.save();
    const colorMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
    const hue = colorMatch ? colorMatch[1] : 200;

    // 1. 核心浓墨层
    traceCtx.globalAlpha = 0.35;
    const grad = traceCtx.createRadialGradient(x, y, 0, x, y, 150);
    grad.addColorStop(0, `hsla(${hue}, 80%, 40%, 0.6)`);
    grad.addColorStop(1, `hsla(${hue}, 80%, 40%, 0)`);
    traceCtx.fillStyle = grad;
    traceCtx.beginPath();
    traceCtx.arc(x, y, 150, 0, Math.PI * 2);
    traceCtx.fill();

    // 2. 广域喷溅墨点
    for (let i = 0; i < 45; i++) {
        const ang = Math.random() * Math.PI * 2;
        const dist = Math.random() * 400; // 扩散半径增加到400
        const r = Math.random() * 15 + 2;
        const alpha = Math.max(0, 0.3 - (dist/400));
        traceCtx.globalAlpha = alpha;
        traceCtx.fillStyle = color;
        traceCtx.beginPath();
        traceCtx.arc(x + Math.cos(ang)*dist, y + Math.sin(ang)*dist, r, 0, Math.PI * 2);
        traceCtx.fill();
    }

    // 3. 缥缈墨痕
    traceCtx.globalAlpha = 0.05;
    for(let i=0; i<10; i++) {
        const r = Math.random() * 80 + 20;
        const ox = (Math.random()-0.5) * 600;
        const oy = (Math.random()-0.5) * 400;
        traceCtx.beginPath();
        traceCtx.arc(x + ox, y + oy, r, 0, Math.PI * 2);
        traceCtx.fill();
    }
    traceCtx.restore();
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    traceCanvas.width = width;
    traceCanvas.height = height;
    
    const cols = Math.floor(width / 100);
    columnHues = [];
    for (let i = 0; i < cols; i++) {
        columnHues.push(Math.floor((i * 360 / cols) % 360));
    }
}
window.addEventListener('resize', resize);
resize();

function spawnBricks(y = 50, density = 0.8) {
    const cols = Math.floor(width / 100);
    const bW = (width - 40) / cols;
    for (let i = 0; i < cols; i++) {
        if (Math.random() > density) {
            const h = columnHues[i];
            bricks.push({
                x: 20 + i * bW, y: y,
                w: bW - 16, h: 26,
                color: `hsl(${h}, 80%, 65%)`
            });
        }
    }
}

function initGame() {
    score = 0; launchCount = 0; isGameOver = false;
    balls = []; bricks = []; particles = [];
    scoreEl.innerText = "0"; launchEl.innerText = "0";
    gameOverScreen.style.display = 'none';
    traceCtx.clearRect(0, 0, width, height);
    for(let i = 0; i < 3; i++) spawnBricks(80 + i * 45, 0.85);
}

function getStringY(x) {
    const xPos = x / width * 3.5;
    return height * 0.86 + Math.sin(xPos + waveTime * 0.25) * 20 + Math.cos(xPos * 0.7 - waveTime * 0.15) * 15;
}

canvas.addEventListener('mousedown', (e) => {
    initAudio();
    if (isGameOver) return;
    if (e.clientY > height / 2) {
        balls.push({ x: e.clientX, y: e.clientY, vx: (Math.random()-0.5)*4, vy: 9, radius: 9, hue: Math.random()*360 });
        launchCount++;
        playBassNote(200);
        if (launchCount >= 3) {
            launchCount = 0;
            bricks.forEach(b => b.y += 50);
            spawnBricks(50, 0.75);
            if (bricks.some(b => b.y + b.h > height / 2)) {
                isGameOver = true;
                gameOverScreen.style.display = 'block';
            }
        }
        launchEl.innerText = launchCount;
    }
});

gameOverScreen.addEventListener('click', initGame);

function update() {
    if (isGameOver) return requestAnimationFrame(update);
    waveTime += 0.02; 

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vy += 0.15; p.vx *= 0.985;
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }

    balls = balls.filter(ball => {
        ball.vy += 0.3; ball.x += ball.vx; ball.y += ball.vy;

        if (ball.y >= height / 2) {
            if (ball.x < 0 || ball.x > width) {
                ball.vx *= -0.9;
                ball.x = ball.x < 0 ? 0 : width;
            }
        } else if (ball.x < 0 || ball.x > width) return false;

        const sY = getStringY(ball.x);
        if (ball.y + ball.radius > sY && ball.vy > 0) {
            ball.y = sY - ball.radius; ball.vy = -17;
            playBassNote(60);
        }

        bricks.forEach((b, i) => {
            if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                playPianoNote(ball.x);
                drawInkSplatter(b.x + b.w/2, b.y + b.h/2, b.color);
                spawnParticles(b.x + b.w/2, b.y + b.h/2, b.color, 'explode', 70);
                bricks.splice(i, 1);
                ball.vy *= -1.05;
                score += 100; scoreEl.innerText = score;
            }
        });
        return ball.y < height + 100;
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.fillStyle = 'rgba(1, 1, 3, 0.35)';
    ctx.fillRect(0, 0, width, height);
    ctx.drawImage(traceCanvas, 0, 0);

    // 生死线
    ctx.setLineDash([10, 15]);
    ctx.strokeStyle = 'rgba(255, 50, 50, 0.3)';
    ctx.beginPath(); ctx.moveTo(0, height/2); ctx.lineTo(width, height/2); ctx.stroke();
    ctx.setLineDash([]);

    // 侧边能量
    const glow = 0.2 + Math.sin(waveTime) * 0.1;
    ctx.fillStyle = `rgba(0, 242, 255, ${glow})`;
    ctx.fillRect(0, height/2, 5, height/2);
    ctx.fillRect(width-5, height/2, 5, height/2);

    // 粒子
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    ctx.globalAlpha = 1;

    // 砖块 - 极慢流光
    bricks.forEach(b => {
        const flow = (waveTime * 0.08) % 1;
        const grad = ctx.createLinearGradient(b.x, b.y, b.x + b.w, b.y + b.h);
        grad.addColorStop(flow, b.color);
        grad.addColorStop((flow + 0.15)%1, '#fff');
        grad.addColorStop((flow + 0.3)%1, b.color);

        ctx.fillStyle = 'rgba(5, 5, 15, 0.9)';
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2.5;
        ctx.strokeRect(b.x, b.y, b.w, b.h);
    });

    // 琴弦
    ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 4;
    ctx.beginPath();
    for(let x=0; x<=width; x+=10) {
        const y = getStringY(x);
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // 小球
    balls.forEach(ball => {
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fill();
    });
}

initGame();
update();
</script>
</body>
</html>
